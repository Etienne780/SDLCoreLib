#pragma once
#include <map>
#include <cstdint>
#include <limits>

#include <CoreLib/Log.h>
#include <CoreLib/FormatUtils.h>

enum class IDOrder {
	// IDs are assigned in no strict order:
	// - IDFallback is on by default
	// - If available, IDs are taken from the free ID pool (m_freeIDs).
	// - Otherwise, new IDs are generated by incrementing m_idCounter.
	// This mode does not enforce ascending or descending ordering.
	RANDOME = 0,

	// IDs are assigned in ascending order:
	// - IDs are generated sequentially starting from 0 (or the Reset start value).
	// - Once the uint limit is reached, m_idFallback is set to true and
	//   IsIDFallback() will return true, indicating that no further ascending IDs
	//   can be generated.
	ASCENDING,

	// IDs are assigned in descending order:
	// - IDs are generated sequentially in decreasing order starting from UINT_MAX
	//   (or the Reset start value).
	// - Once the lower limit (0) is reached, m_idFallback is set to true and
	//   IsIDFallback() will return true, indicating that no further descending IDs
	//   can be generated.
	DESCENDING
};

template<typename ID_TYPE, ID_TYPE INVALID_ID>
class IDManager {
public:
	IDManager(IDOrder order = IDOrder::RANDOME)
		: IDManager(0, order) {
	}

	IDManager(ID_TYPE startCount, IDOrder order = IDOrder::RANDOME) {
		m_idCounter = startCount;
		SetIDOrder(order);
	}

	~IDManager() = default;

	bool IsIDFallback() {
		return m_idFallback;
	}

	/**
	* @brief returns a unique ID_TYPE id or INVALID_ID if none available
	*/
	ID_TYPE GetNewUniqueIdentifier() {
		switch (m_order) {
		case IDOrder::RANDOME: return GetNewUniqueIdentifierRandom();
		case IDOrder::ASCENDING: return GetNewUniqueIdentifierAscending();
		case IDOrder::DESCENDING: return GetNewUniqueIdentifierDescending();
		}

		return m_invalidID;
	}

	/*
	* @brief Frees an ID so it can be reused later
	*/
	void FreeUniqueIdentifier(ID_TYPE id) {
		if (id == m_invalidID)
			return;

		// Find the first range with start > id
		auto it = m_rangeFreeIDs.upper_bound(id);

		ID_TYPE newStart = id;
		ID_TYPE newEnd = id;

		bool mergedLeft = false;
		bool mergedRight = false;

		// check left neighbor (previous range) to see if id connects
		if (it != m_rangeFreeIDs.begin()) {
			auto prev = std::prev(it);
			if (prev->second + 1 == id) {
				// extend previous range to include id
				prev->second = id;
				newStart = prev->first;
				newEnd = prev->second;
				mergedLeft = true;
			}
			else if (prev->first <= id && id <= prev->second) {
				// id already contained in a free range -> nothing to do
				return;
			}
		}

		// check right neighbor (it) to see if id connects
		if (it != m_rangeFreeIDs.end()) {
			if (it->first == id + 1) {
				// extend right range to include id
				if (mergedLeft) {
					// we previously extended left; now merge both ranges
					auto leftIt = m_rangeFreeIDs.find(newStart);
					if (leftIt != m_rangeFreeIDs.end()) {
						leftIt->second = it->second; // merge
						m_rangeFreeIDs.erase(it);
						return;
					}
				}
				else {
					// extend right range downward
					ID_TYPE oldEnd = it->second;
					ID_TYPE oldStart = it->first;
					m_rangeFreeIDs.erase(it);
					m_rangeFreeIDs.emplace(id, oldEnd);
					return;
				}
				mergedRight = true;
			}
			else if (it->first <= id && id <= it->second) {
				// id already contained in right range -> nothing to do
				return;
			}
		}


		if (!mergedLeft && !mergedRight) {
			// create new single-id range
			m_rangeFreeIDs.emplace(id, id);
		}
	}

	/*
	* @brief resets the ID manager
	* @param sets the start value of the next free id
	*/
	void Reset(ID_TYPE startValue = 0) {
		m_rangeFreeIDs.clear();

		switch (m_order) {
		case IDOrder::RANDOME:
			m_idCounter = startValue;
			m_idFallback = true;
			break;
		case IDOrder::ASCENDING:
			m_idCounter = startValue;
			m_idFallback = false;
			break;
		case IDOrder::DESCENDING:
			m_idCounter = startValue;
			m_idFallback = false;
			break;
		}
	}

	/*
	* @brief Sets the order in which new IDs are returned. Calls Reset on this Element. Default is IDOrder::RANDOME.
	*
	* - IDOrder::RANDOME:
	*	IDFallback is on by default
	*   IDs are returned without a strict sequence. The manager first tries to reuse
	*   IDs from the free ID pool (m_freeIDs). If none are available, m_idCounter
	*   is incremented to generate a new ID.
	*
	* - IDOrder::ASCENDING:
	*   IDs are returned in ascending order, starting at 0 (or the Reset start value).
	*   When the maximum uint value is reached, m_idFallback is set to true and
	*   IsIDFallback() will return true.
	*
	* - IDOrder::DESCENDING:
	*   IDs are returned in descending order, starting at UINT_MAX (or the Reset start value).
	*   When 0 is reached, m_idFallback is set to true and IsIDFallback() will return true.
	*/
	void SetIDOrder(IDOrder value) {
		m_order = value;
		Reset((value == IDOrder::DESCENDING) ? idLimit : 0);
	}

	/**
	* @brief Returns the current set of free-ID ranges.
	*
	* This function is intended for debug builds only.
	* When called in non-debug configurations, it emits a warning
	* and returns an empty static map.
	*
	* @return const reference to a map where each entry represents a free ID range:
	*         - key   = range start
	*         - value = range end
	*/
#ifdef DEBUG
	const std::map<ID_TYPE, ID_TYPE>& IDManager::DebugGetRanges() const {
		return m_rangeFreeIDs;
	}
#else
	const std::map<ID_TYPE, ID_TYPE>& IDManager::DebugGetRanges() const {
		Log::Warn("IDManager::DebugGetRanges: Called DebugGetRanges outside of debug builds!");
		static std::map<ID_TYPE, ID_TYPE> dummy;
		return dummy;
	}
#endif

private:
	static inline constexpr ID_TYPE idLimit = std::numeric_limits<ID_TYPE>::max();

	// store free id ranges as [start, end] (inclusive)
	// use std::map keyed by start -> end for fast neighbor lookups and merging
	std::map<ID_TYPE, ID_TYPE> m_rangeFreeIDs;

	ID_TYPE m_invalidID = INVALID_ID;
	ID_TYPE m_idCounter = 0;
	bool m_idFallback = false; // becomes true when sequential generation exhausted
	IDOrder m_order = IDOrder::RANDOME;

	// internal helpers

	ID_TYPE SkipInvalid(ID_TYPE id) {
		if (id != m_invalidID)
			return id;

		// invalidID is reserved, get next ID
		return GetNewUniqueIdentifier();
	}

	ID_TYPE GetNewUniqueIdentifierFallback() {
		if (!m_idFallback) {
			m_idFallback = true;
			Log::Warn("IDManager: Max ID limit reached, using fallback IDs from free pool");
		}

		if (!m_rangeFreeIDs.empty()) {
			return GetRangeFreeID();
		}

		Log::Warn("IDManager: Can't find any free IDs, free pool is empty!");
		return m_invalidID;
	}

	/**
	* @brief Retrieves the lowest available free ID from the free-range pool.
	*
	* This function takes the first (lowest) free ID from the internal free-range
	* map and removes it from the pool. If the range contains more than one ID,
	* the range is shrunk accordingly.
	*
	* The reserved INVALID_ID is explicitly skipped and never returned.
	* If INVALID_ID is encountered inside a free range, it is silently discarded
	* and the next free ID is evaluated.
	*
	* @return A valid free ID, or INVALID_ID if no usable free IDs are available.
	*/
	ID_TYPE GetRangeFreeID() {
		while (!m_rangeFreeIDs.empty()) {
			auto it = m_rangeFreeIDs.begin();
			ID_TYPE id = it->first;

			if (it->first == it->second) {
				m_rangeFreeIDs.erase(it);
			}
			else {
				ID_TYPE newStart = it->first + 1;
				ID_TYPE oldEnd = it->second;
				m_rangeFreeIDs.erase(it);
				m_rangeFreeIDs.emplace(newStart, oldEnd);
			}

			if (id != m_invalidID)
				return id;
		}

		return m_invalidID;
	}

	ID_TYPE GetNewUniqueIdentifierRandom() {
		ID_TYPE id;

		if (!m_rangeFreeIDs.empty()) {
			id = GetRangeFreeID();
		}
		else {
			if (m_idCounter != idLimit) {
				id = m_idCounter++;
			}
			else {
				id = idLimit;// will trigger fallback next call
			}
		}

		return SkipInvalid(id);
	}

	ID_TYPE GetNewUniqueIdentifierAscending() {
		ID_TYPE id;

		if (m_idFallback) {
			id = GetNewUniqueIdentifierFallback();
		}
		else {
			if (m_idCounter != idLimit) {
				id = m_idCounter++;
			}
			else {
				id = GetNewUniqueIdentifierFallback();
			}
		}

		return SkipInvalid(id);
	}

	ID_TYPE GetNewUniqueIdentifierDescending() {
		ID_TYPE id;

		if (m_idFallback) {
			id = GetNewUniqueIdentifierFallback();
		}
		else {
			if (m_idCounter != 0) {
				id = m_idCounter--;
			}
			else {
				id = GetNewUniqueIdentifierFallback();
			}
		}

		return SkipInvalid(id);
	}
};

template<>
static inline std::string FormatUtils::toString<IDOrder>(IDOrder order) {
	switch (order)
	{
	case IDOrder::RANDOME:		return "Random";
	case IDOrder::ASCENDING:	return "Ascending";
	case IDOrder::DESCENDING:	return "Descending";
	default:					return "UNKOWN";
	}
}