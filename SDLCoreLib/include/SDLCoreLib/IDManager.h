#pragma once
#include <map>
#include <cstdint>
#include <limits>
#include <CoreLib/FormatUtils.h>

namespace SDLCore {

	enum class IDOrder {
		// IDs are assigned in no strict order:
		// - IDFallback is on by default
		// - If available, IDs are taken from the free ID pool (m_freeIDs).
		// - Otherwise, new IDs are generated by incrementing m_idCounter.
		// This mode does not enforce ascending or descending ordering.
		RANDOME = 0,

		// IDs are assigned in ascending order:
		// - IDs are generated sequentially starting from 0 (or the Reset start value).
		// - Once the uint limit is reached, m_idFallback is set to true and
		//   IsIDFallback() will return true, indicating that no further ascending IDs
		//   can be generated.
		ASCENDING,

		// IDs are assigned in descending order:
		// - IDs are generated sequentially in decreasing order starting from UINT_MAX
		//   (or the Reset start value).
		// - Once the lower limit (0) is reached, m_idFallback is set to true and
		//   IsIDFallback() will return true, indicating that no further descending IDs
		//   can be generated.
		DESCENDING
	};

	class IDManager {
	public:
		IDManager(IDOrder order = IDOrder::RANDOME);
		IDManager(uint32_t startCount, IDOrder order = IDOrder::RANDOME);
		~IDManager() = default;

		bool IsIDFallback();

		/**
		* @brief returns a unique uint32_t id or SDLCORE_INVALID_ID if none available
		*/
		uint32_t GetNewUniqueIdentifier();

		/*
		* @brief Frees an ID so it can be reused later
		*/
		void FreeUniqueIdentifier(uint32_t id);

		/*
		* @brief resets the ID manager
		* @param sets the start value of the next free id
		*/
		void Reset(uint32_t startValue = 0);

		/*
		* @brief Sets the order in which new IDs are returned. Calls Reset on this Element. Default is IDOrder::RANDOME.
		*
		* - IDOrder::RANDOME:
		*	IDFallback is on by default
		*   IDs are returned without a strict sequence. The manager first tries to reuse
		*   IDs from the free ID pool (m_freeIDs). If none are available, m_idCounter
		*   is incremented to generate a new ID.
		*
		* - IDOrder::ASCENDING:
		*   IDs are returned in ascending order, starting at 0 (or the Reset start value).
		*   When the maximum uint value is reached, m_idFallback is set to true and
		*   IsIDFallback() will return true.
		*
		* - IDOrder::DESCENDING:
		*   IDs are returned in descending order, starting at UINT_MAX (or the Reset start value).
		*   When 0 is reached, m_idFallback is set to true and IsIDFallback() will return true.
		*/
		void SetIDOrder(IDOrder value);

		/**
		* @brief Returns the current set of free-ID ranges.
		*
		* This function is intended for debug builds only.
		* When called in non-debug configurations, it emits a warning
		* and returns an empty static map.
		*
		* @return const reference to a map where each entry represents a free ID range:
		*         - key   = range start
		*         - value = range end
		*/
		const std::map<uint32_t, uint32_t>& DebugGetRanges() const;

	private:
		static inline constexpr uint32_t idLimit = std::numeric_limits<uint32_t>::max();

		// store free id ranges as [start, end] (inclusive)
		// use std::map keyed by start -> end for fast neighbor lookups and merging
		std::map<uint32_t, uint32_t> m_rangeFreeIDs;

		uint32_t m_idCounter = 0;
		bool m_idFallback = false; // becomes true when sequential generation exhausted
		IDOrder m_order = IDOrder::RANDOME;

		// internal helpers

		uint32_t GetNewUniqueIdentifierFallback();
		uint32_t GetRangeFreeID();

		uint32_t GetNewUniqueIdentifierRandom();
		uint32_t GetNewUniqueIdentifierAscending();
		uint32_t GetNewUniqueIdentifierDescending();
	};

}

template<>
static inline std::string FormatUtils::toString<SDLCore::IDOrder>(SDLCore::IDOrder order) {
	switch (order)
	{
	case SDLCore::IDOrder::RANDOME:		return "Random";
	case SDLCore::IDOrder::ASCENDING:	return "Ascending";
	case SDLCore::IDOrder::DESCENDING:	return "Descending";
	default:							return "UNKOWN";
	}
}