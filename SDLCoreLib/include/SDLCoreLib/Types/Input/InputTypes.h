#pragma once
#include <string>
#include <CoreLib/FormatUtils.h>
#include <SDL3/SDL.h>

namespace SDLCore {

    /**
     * @brief Supported input device types
     */
    enum class InputDeviceType {
        Keyboard,
        Mouse,
        Gamepad
    };

    /**
    * @brief Tracks the state of a single key or button.
    * This class assumes per-frame updates via 'update()'.
    */
    class KeyState {
    public:
        bool isPressed = false;     // true if currently pressed
        bool isRepeating = false;   // true if SDL_EVENT_KEY_DOWN with repeat
        bool wasPressed = false;    // true only in the frame when the key was pressed
        bool wasReleased = false;   // true only in the frame when the key was released

        /**
        * @brief Called once per frame to clear transient flags.
        */
        void Update();

        /**
        * @brief Updates state based on SDL keyboard or mouse button event.
        * @param pressed true if pressed, false if released
        * @param repeat true if the event was generated by key repeat
        */
        void SetState(bool pressed, bool repeat = false);

        /**
        * @brief True if key was pressed this frame.
        */
        bool JustPressed() const;

        /**
        * @brief True if key was released this frame.
        */
        bool JustReleased() const;
    };

    /**
    * @brief Internal key code mapping using SDL3 scancodes.
    * SDL uses scancodes (physical location on keyboard) and keycodes (logical symbol).
    * Scancodes are preferable for consistent input layout handling.
    */
    enum class KeyCode {
        UNKNOWN = SDL_SCANCODE_UNKNOWN,

        A = SDL_SCANCODE_A,
        B = SDL_SCANCODE_B,
        C = SDL_SCANCODE_C,
        D = SDL_SCANCODE_D,
        E = SDL_SCANCODE_E,
        F = SDL_SCANCODE_F,
        G = SDL_SCANCODE_G,
        H = SDL_SCANCODE_H,
        I = SDL_SCANCODE_I,
        J = SDL_SCANCODE_J,
        K = SDL_SCANCODE_K,
        L = SDL_SCANCODE_L,
        M = SDL_SCANCODE_M,
        N = SDL_SCANCODE_N,
        O = SDL_SCANCODE_O,
        P = SDL_SCANCODE_P,
        Q = SDL_SCANCODE_Q,
        R = SDL_SCANCODE_R,
        S = SDL_SCANCODE_S,
        T = SDL_SCANCODE_T,
        U = SDL_SCANCODE_U,
        V = SDL_SCANCODE_V,
        W = SDL_SCANCODE_W,
        X = SDL_SCANCODE_X,
        Y = SDL_SCANCODE_Y,
        Z = SDL_SCANCODE_Z,

        NUM_1 = SDL_SCANCODE_1,
        NUM_2 = SDL_SCANCODE_2,
        NUM_3 = SDL_SCANCODE_3,
        NUM_4 = SDL_SCANCODE_4,
        NUM_5 = SDL_SCANCODE_5,
        NUM_6 = SDL_SCANCODE_6,
        NUM_7 = SDL_SCANCODE_7,
        NUM_8 = SDL_SCANCODE_8,
        NUM_9 = SDL_SCANCODE_9,
        NUM_0 = SDL_SCANCODE_0,

        RETURN      = SDL_SCANCODE_RETURN,
        ESCAPE      = SDL_SCANCODE_ESCAPE,
        BACKSPACE   = SDL_SCANCODE_BACKSPACE,
        TAB         = SDL_SCANCODE_TAB,
        SPACE       = SDL_SCANCODE_SPACE,

        MINUS           = SDL_SCANCODE_MINUS,
        EQUALS          = SDL_SCANCODE_EQUALS,
        LEFTBRACKET     = SDL_SCANCODE_LEFTBRACKET,
        RIGHTBRACKET    = SDL_SCANCODE_RIGHTBRACKET,
        BACKSLASH       = SDL_SCANCODE_BACKSLASH,
        SEMICOLON       = SDL_SCANCODE_SEMICOLON,
        APOSTROPHE      = SDL_SCANCODE_APOSTROPHE,
        GRAVE           = SDL_SCANCODE_GRAVE,
        COMMA           = SDL_SCANCODE_COMMA,
        PERIOD          = SDL_SCANCODE_PERIOD,
        SLASH           = SDL_SCANCODE_SLASH,

        CAPSLOCK = SDL_SCANCODE_CAPSLOCK,
        F1 = SDL_SCANCODE_F1,
        F2 = SDL_SCANCODE_F2,
        F3 = SDL_SCANCODE_F3,
        F4 = SDL_SCANCODE_F4,
        F5 = SDL_SCANCODE_F5,
        F6 = SDL_SCANCODE_F6,
        F7 = SDL_SCANCODE_F7,
        F8 = SDL_SCANCODE_F8,
        F9 = SDL_SCANCODE_F9,
        F10 = SDL_SCANCODE_F10,
        F11 = SDL_SCANCODE_F11,
        F12 = SDL_SCANCODE_F12,

        PRINTSCREEN = SDL_SCANCODE_PRINTSCREEN,
        SCROLLLOCK  = SDL_SCANCODE_SCROLLLOCK,
        PAUSE       = SDL_SCANCODE_PAUSE,
        INSERT      = SDL_SCANCODE_INSERT,
        HOME        = SDL_SCANCODE_HOME,
        PAGEUP      = SDL_SCANCODE_PAGEUP,
        DELETE      = SDL_SCANCODE_DELETE,
        END         = SDL_SCANCODE_END,
        PAGEDOWN    = SDL_SCANCODE_PAGEDOWN,
        RIGHT       = SDL_SCANCODE_RIGHT,
        LEFT        = SDL_SCANCODE_LEFT,
        DOWN        = SDL_SCANCODE_DOWN,
        UP          = SDL_SCANCODE_UP,

        LCTRL   = SDL_SCANCODE_LCTRL,
        LSHIFT  = SDL_SCANCODE_LSHIFT,
        LALT    = SDL_SCANCODE_LALT,
        LGUI    = SDL_SCANCODE_LGUI,
        RCTRL   = SDL_SCANCODE_RCTRL,
        RSHIFT  = SDL_SCANCODE_RSHIFT,
        RALT    = SDL_SCANCODE_RALT,
        RGUI    = SDL_SCANCODE_RGUI,
        MENU    = SDL_SCANCODE_MENU
    };

    /**
    * @brief Mouse buttons as defined by SDL3.
    */
    enum class MouseButton {
        UNKNOWN = 0,
        LEFT    = SDL_BUTTON_LEFT,
        MIDDLE  = SDL_BUTTON_MIDDLE,
        RIGHT   = SDL_BUTTON_RIGHT,
        X1      = SDL_BUTTON_X1,
        X2      = SDL_BUTTON_X2
    };

    /**
    * @brief Gamepad button identifiers (SDL 3.2.0 mapping).
    */
    enum class GamepadButton : int {
        UNKNOWN         = SDL_GAMEPAD_BUTTON_INVALID,
        SOUTH           = SDL_GAMEPAD_BUTTON_SOUTH, // Bottom face button (A / Cross)
        EAST            = SDL_GAMEPAD_BUTTON_EAST,  // Right face button (B / Circle)
        WEST            = SDL_GAMEPAD_BUTTON_WEST,  // Left face button (X / Square)
        NORTH           = SDL_GAMEPAD_BUTTON_NORTH, // Top face button (Y / Triangle)
        BACK            = SDL_GAMEPAD_BUTTON_BACK,
        GUIDE           = SDL_GAMEPAD_BUTTON_GUIDE,
        START           = SDL_GAMEPAD_BUTTON_START,
        LEFT_STICK      = SDL_GAMEPAD_BUTTON_LEFT_STICK,
        RIGHT_STICK     = SDL_GAMEPAD_BUTTON_RIGHT_STICK,
        LEFT_SHOULDER   = SDL_GAMEPAD_BUTTON_LEFT_SHOULDER,
        RIGHT_SHOULDER  = SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER,
        DPAD_UP         = SDL_GAMEPAD_BUTTON_DPAD_UP,
        DPAD_DOWN       = SDL_GAMEPAD_BUTTON_DPAD_DOWN,
        DPAD_LEFT       = SDL_GAMEPAD_BUTTON_DPAD_LEFT,
        DPAD_RIGHT      = SDL_GAMEPAD_BUTTON_DPAD_RIGHT,
        MISC1           = SDL_GAMEPAD_BUTTON_MISC1,         /**< Additional button (e.g. Xbox Series X share button, PS5 microphone button, Nintendo Switch Pro capture button, Amazon Luna microphone button, Google Stadia capture button) */
        RIGHT_PADDLE1   = SDL_GAMEPAD_BUTTON_RIGHT_PADDLE1, /**< Upper or primary paddle, under your right hand (e.g. Xbox Elite paddle P1, DualSense Edge RB button, Right Joy-Con SR button) */
        LEFT_PADDLE1    = SDL_GAMEPAD_BUTTON_LEFT_PADDLE1,  /**< Upper or primary paddle, under your left hand (e.g. Xbox Elite paddle P3, DualSense Edge LB button, Left Joy-Con SL button) */
        RIGHT_PADDLE2   = SDL_GAMEPAD_BUTTON_RIGHT_PADDLE2, /**< Lower or secondary paddle, under your right hand (e.g. Xbox Elite paddle P2, DualSense Edge right Fn button, Right Joy-Con SL button) */
        LEFT_PADDLE2    = SDL_GAMEPAD_BUTTON_LEFT_PADDLE2,  /**< Lower or secondary paddle, under your left hand (e.g. Xbox Elite paddle P4, DualSense Edge left Fn button, Left Joy-Con SR button) */
        TOUCHPAD        = SDL_GAMEPAD_BUTTON_TOUCHPAD,      /**< PS4/PS5 touchpad button */
        MISC2           = SDL_GAMEPAD_BUTTON_MISC2,         /**< Additional button */
        MISC3           = SDL_GAMEPAD_BUTTON_MISC3,         /**< Additional button (e.g. Nintendo GameCube left trigger click) */
        MISC4           = SDL_GAMEPAD_BUTTON_MISC4,         /**< Additional button (e.g. Nintendo GameCube right trigger click) */
        MISC5           = SDL_GAMEPAD_BUTTON_MISC5,         /**< Additional button */
        MISC6           = SDL_GAMEPAD_BUTTON_MISC6,         /**< Additional button */
        COUNT           = SDL_GAMEPAD_BUTTON_COUNT
    };

    /**
     * @brief Gamepad analog axes.
     */
    enum class GamepadAxisType : int {
        UNKNOWN         = SDL_GAMEPAD_AXIS_INVALID,
        LEFT_X          = SDL_GAMEPAD_AXIS_LEFTX,
        LEFT_Y          = SDL_GAMEPAD_AXIS_LEFTY,
        RIGHT_X         = SDL_GAMEPAD_AXIS_RIGHTX,
        RIGHT_Y         = SDL_GAMEPAD_AXIS_RIGHTY,
        LEFT_TRIGGER    = SDL_GAMEPAD_AXIS_LEFT_TRIGGER,
        RIGHT_TRIGGER   = SDL_GAMEPAD_AXIS_RIGHT_TRIGGER,
        COUNT           = SDL_GAMEPAD_AXIS_COUNT
    };

    /**
     * @brief Gamepad device metadata (SDL 3.2.0).
     */
    struct GamepadDevice {
        SDL_Gamepad* handle = nullptr;
        SDL_JoystickID id = 0;
        SDL_GamepadType type = SDL_GAMEPAD_TYPE_UNKNOWN;
        std::string name;
        bool connected = false;

        bool isValid() const { return handle != nullptr && connected; }
    };

    inline std::string ToString(KeyCode key) {
        switch (key) {
        case KeyCode::UNKNOWN: return "UNKNOWN";
        case KeyCode::A: return "A";
        case KeyCode::B: return "B";
        case KeyCode::C: return "C";
        case KeyCode::D: return "D";
        case KeyCode::E: return "E";
        case KeyCode::F: return "F";
        case KeyCode::G: return "G";
        case KeyCode::H: return "H";
        case KeyCode::I: return "I";
        case KeyCode::J: return "J";
        case KeyCode::K: return "K";
        case KeyCode::L: return "L";
        case KeyCode::M: return "M";
        case KeyCode::N: return "N";
        case KeyCode::O: return "O";
        case KeyCode::P: return "P";
        case KeyCode::Q: return "Q";
        case KeyCode::R: return "R";
        case KeyCode::S: return "S";
        case KeyCode::T: return "T";
        case KeyCode::U: return "U";
        case KeyCode::V: return "V";
        case KeyCode::W: return "W";
        case KeyCode::X: return "X";
        case KeyCode::Y: return "Y";
        case KeyCode::Z: return "Z";

        case KeyCode::NUM_1: return "1";
        case KeyCode::NUM_2: return "2";
        case KeyCode::NUM_3: return "3";
        case KeyCode::NUM_4: return "4";
        case KeyCode::NUM_5: return "5";
        case KeyCode::NUM_6: return "6";
        case KeyCode::NUM_7: return "7";
        case KeyCode::NUM_8: return "8";
        case KeyCode::NUM_9: return "9";
        case KeyCode::NUM_0: return "0";

        case KeyCode::RETURN: return "RETURN";
        case KeyCode::ESCAPE: return "ESCAPE";
        case KeyCode::BACKSPACE: return "BACKSPACE";
        case KeyCode::TAB: return "TAB";
        case KeyCode::SPACE: return "SPACE";

        case KeyCode::MINUS: return "MINUS";
        case KeyCode::EQUALS: return "EQUALS";
        case KeyCode::LEFTBRACKET: return "LEFTBRACKET";
        case KeyCode::RIGHTBRACKET: return "RIGHTBRACKET";
        case KeyCode::BACKSLASH: return "BACKSLASH";
        case KeyCode::SEMICOLON: return "SEMICOLON";
        case KeyCode::APOSTROPHE: return "APOSTROPHE";
        case KeyCode::GRAVE: return "GRAVE";
        case KeyCode::COMMA: return "COMMA";
        case KeyCode::PERIOD: return "PERIOD";
        case KeyCode::SLASH: return "SLASH";

        case KeyCode::CAPSLOCK: return "CAPSLOCK";
        case KeyCode::F1: return "F1";
        case KeyCode::F2: return "F2";
        case KeyCode::F3: return "F3";
        case KeyCode::F4: return "F4";
        case KeyCode::F5: return "F5";
        case KeyCode::F6: return "F6";
        case KeyCode::F7: return "F7";
        case KeyCode::F8: return "F8";
        case KeyCode::F9: return "F9";
        case KeyCode::F10: return "F10";
        case KeyCode::F11: return "F11";
        case KeyCode::F12: return "F12";

        case KeyCode::PRINTSCREEN: return "PRINTSCREEN";
        case KeyCode::SCROLLLOCK: return "SCROLLLOCK";
        case KeyCode::PAUSE: return "PAUSE";
        case KeyCode::INSERT: return "INSERT";
        case KeyCode::HOME: return "HOME";
        case KeyCode::PAGEUP: return "PAGEUP";
        case KeyCode::DELETE: return "DELETE";
        case KeyCode::END: return "END";
        case KeyCode::PAGEDOWN: return "PAGEDOWN";
        case KeyCode::RIGHT: return "RIGHT";
        case KeyCode::LEFT: return "LEFT";
        case KeyCode::DOWN: return "DOWN";
        case KeyCode::UP: return "UP";

        case KeyCode::LCTRL: return "LCTRL";
        case KeyCode::LSHIFT: return "LSHIFT";
        case KeyCode::LALT: return "LALT";
        case KeyCode::LGUI: return "LGUI";
        case KeyCode::RCTRL: return "RCTRL";
        case KeyCode::RSHIFT: return "RSHIFT";
        case KeyCode::RALT: return "RALT";
        case KeyCode::RGUI: return "RGUI";
        case KeyCode::MENU: return "MENU";

        default: return "INVALID_KEYCODE";

        }
    }

    inline std::string ToString(MouseButton button) {
        switch (button) {
        case MouseButton::UNKNOWN: return "UNKNOWN";
        case MouseButton::LEFT: return "LEFT";
        case MouseButton::MIDDLE: return "MIDDLE";
        case MouseButton::RIGHT: return "RIGHT";
        case MouseButton::X1: return "X1";
        case MouseButton::X2: return "X2";
        default: return "INVALID_MOUSE_BUTTON";
        }
    }

    inline std::string ToString(GamepadButton button) {
        switch (button) {
        case GamepadButton::UNKNOWN: return "UNKNOWN";
        case GamepadButton::SOUTH: return "SOUTH";
        case GamepadButton::EAST: return "EAST";
        case GamepadButton::WEST: return "WEST";
        case GamepadButton::NORTH: return "NORTH";
        case GamepadButton::BACK: return "BACK";
        case GamepadButton::GUIDE: return "GUIDE";
        case GamepadButton::START: return "START";
        case GamepadButton::LEFT_STICK: return "LEFT_STICK";
        case GamepadButton::RIGHT_STICK: return "RIGHT_STICK";
        case GamepadButton::LEFT_SHOULDER: return "LEFT_SHOULDER";
        case GamepadButton::RIGHT_SHOULDER: return "RIGHT_SHOULDER";
        case GamepadButton::DPAD_UP: return "DPAD_UP";
        case GamepadButton::DPAD_DOWN: return "DPAD_DOWN";
        case GamepadButton::DPAD_LEFT: return "DPAD_LEFT";
        case GamepadButton::DPAD_RIGHT: return "DPAD_RIGHT";
        case GamepadButton::MISC1: return "MISC1";
        case GamepadButton::RIGHT_PADDLE1: return "RIGHT_PADDLE1";
        case GamepadButton::LEFT_PADDLE1: return "LEFT_PADDLE1";
        case GamepadButton::RIGHT_PADDLE2: return "RIGHT_PADDLE2";
        case GamepadButton::LEFT_PADDLE2: return "LEFT_PADDLE2";
        case GamepadButton::TOUCHPAD: return "TOUCHPAD";
        case GamepadButton::MISC2: return "MISC2";
        case GamepadButton::MISC3: return "MISC3";
        case GamepadButton::MISC4: return "MISC4";
        case GamepadButton::MISC5: return "MISC5";
        case GamepadButton::MISC6: return "MISC6";
        case GamepadButton::COUNT: return "COUNT";
        default: return "INVALID_GAMEPAD_BUTTON";
        }
    }

    inline std::string ToString(GamepadAxisType axis) {
        switch (axis) {
        case GamepadAxisType::UNKNOWN: return "UNKNOWN";
        case GamepadAxisType::LEFT_X: return "LEFT_X";
        case GamepadAxisType::LEFT_Y: return "LEFT_Y";
        case GamepadAxisType::RIGHT_X: return "RIGHT_X";
        case GamepadAxisType::RIGHT_Y: return "RIGHT_Y";
        case GamepadAxisType::LEFT_TRIGGER: return "LEFT_TRIGGER";
        case GamepadAxisType::RIGHT_TRIGGER: return "RIGHT_TRIGGER";
        case GamepadAxisType::COUNT: return "COUNT";
        default: return "INVALID_GAMEPAD_AXIS";
        }
    }

}

// Format functions for Log or just toString

template<>
static inline std::string FormatUtils::toString<SDLCore::KeyCode>(SDLCore::KeyCode keyCode) {
    return SDLCore::ToString(keyCode);
}

template<>
static inline std::string FormatUtils::toString<SDLCore::MouseButton>(SDLCore::MouseButton mouseButton) {
    return SDLCore::ToString(mouseButton);
}

template<>
static inline std::string FormatUtils::toString<SDLCore::GamepadButton>(SDLCore::GamepadButton gamepadButton) {
    return SDLCore::ToString(gamepadButton);
}

template<>
static inline std::string FormatUtils::toString<SDLCore::GamepadAxisType>(SDLCore::GamepadAxisType  gamepadAxisType) {
    return SDLCore::ToString(gamepadAxisType);
}